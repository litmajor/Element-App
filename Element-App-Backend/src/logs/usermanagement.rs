use crate::db::{create_role, create_user, find_role_by_name, find_user_by_username, Pool, User};
use anyhow::{Result, Context};
use std::error::Error;

// Function to register a new user
pub async fn register_user(
    conn: &Pool,
    username: &str,
    email: &str,
    password: &str,
    role_name: Option<&str>,
  ) -> Result<usize, Box<dyn Error>> {
    let mut connection = conn.begin().await?;
  
    // Check if the username already exists
    let user_exists = find_user_by_username(&mut connection, username).await?;
    if let Some(_) = user_exists {
      return Err(anyhow::anyhow!("User with this username already exists"));
    }
  
    // Hash the password
    let hashed_password = hash_password(password).await?;
  
    // Find the role ID (if provided)
    let role_id = if let Some(name) = role_name {
      let role = find_role_by_name(&mut connection, name).await?;
      match role {
        Some(role) => Some(role.id),
        None => return Err(anyhow::anyhow!("Role not found")),
      }
    } else {
      None
    };
  
    // Create a new user object
    let new_user = User {
      id: 0, // Assuming this is auto-generated by the database
      username: username.to_string(),
      email: email.to_string(),
      hashed_password,
      role_id,
    };
  
    // Insert the new user into the database
    let result = create_user(&mut connection, &new_user).await?;
  
    // Commit the transaction if successful
    connection.commit().await?;
  
    Ok(result)
  }  

// Function to retrieve a user by their username
pub async fn get_user_by_username(conn: &Pool, username: &str) -> Result<Option<User>> {
    find_user_by_username(conn, username).await
}

// Function to create a new role
pub async fn create_new_role(conn: &Pool, role_name: &str) -> Result<usize> {
    let role = Role {
        id: 0, // Assuming this is auto-generated by the database
        name: role_name.to_string(),
    };

    // Insert the new role into the database
    let result = create_role(conn, &role).await?;
    Ok(result)
}

// Function to retrieve a role by its name
pub async fn get_role_by_name(conn: &Pool, role_name: &str) -> Result<Option<Role>> {
    find_role_by_name(conn, role_name).await
}

// Other user management functions can be added here as needed...
#[cfg(test)]
mod tests {
    use super::*;
    use diesel::connection::Connection;
    use diesel::r2d2::{ConnectionManager, PooledConnection};
    use mockall::mock;
    use serial_test::serial;

    mock! {
        ConnectionManager<PgConnection> {}
        impl Connection for PooledConnection<ConnectionManager<PgConnection>> {
            fn execute(&mut self, query: &str) -> QueryResult<usize>;
            fn query_by_index<T, U>(&mut self, source: T) -> QueryResult<Vec<U>>
            where
                T: LoadQuery<Self, U>;
        }
    }

    #[tokio::test]
    #[serial]
    async fn test_register_user() {
        let pool = establish_connection_pool().unwrap();
        let username = "testuser";
        let email = "testuser@example.com";
        let password = "testpassword";
        let role_name = Some("user");

        let result = register_user(&pool, username, email, password, role_name).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    #[serial]
    async fn test_find_user_by_username() {
        let pool = establish_connection_pool().unwrap();
        let username = "testuser";

        let user = find_user_by_username(&pool, username).await.unwrap();
        assert_eq!(user.unwrap().username, username);
    }

    #[tokio::test]
    #[serial]
    async fn test_create_role() {
        let pool = establish_connection_pool().unwrap();
        let role = Role {
            id: 0,
            name: "admin".to_string(),
        };

        let result = create_role(&pool, &role).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    #[serial]
    async fn test_find_role_by_name() {
        let pool = establish_connection_pool().unwrap();
        let role_name = "admin";

        let role = find_role_by_name(&pool, role_name).await.unwrap();
        assert_eq!(role.unwrap().name, role_name);
    }
}





// use crate::db::{create_role, create_user, find_role_by_name, find_user_by_username, Pool, User};
// use anyhow::{Result, Context};
// use std::error::Error;

// // Function to register a new user
// pub async fn register_user(
//     conn: &Pool,
//     username: &str,
//     email: &str,
//     password: &str,
//     role_name: Option<&str>,
//   ) -> Result<usize, Box<dyn Error>> {
//     let mut connection = conn.begin().await?;
  
//     // Check if the username already exists
//     let user_exists = find_user_by_username(&mut connection, username).await?;
//     if let Some(_) = user_exists {
//       return Err(anyhow::anyhow!("User with this username already exists"));
//     }
  
//     // Hash the password
//     let hashed_password = hash_password(password).await?;
  
//     // Find the role ID (if provided)
//     let role_id = if let Some(name) = role_name {
//       let role = find_role_by_name(&mut connection, name).await?;
//       match role {
//         Some(role) => Some(role.id),
//         None => return Err(anyhow::anyhow!("Role not found")),
//       }
//     } else {
//       None
//     };
  
//     // Create a new user object
//     let new_user = User {
//       id: 0, // Assuming this is auto-generated by the database
//       username: username.to_string(),
//       email: email.to_string(),
//       hashed_password,
//       role_id,
//     };
  
//     // Insert the new user into the database
//     let result = create_user(&mut connection, &new_user).await?;
  
//     // Commit the transaction if successful
//     connection.commit().await?;
  
//     Ok(result)
//   }  

// // Function to retrieve a user by their username
// pub async fn get_user_by_username(conn: &Pool, username: &str) -> Result<Option<User>> {
//     find_user_by_username(conn, username).await
// }

// // Function to create a new role
// pub async fn create_new_role(conn: &Pool, role_name: &str) -> Result<usize> {
//     let role = Role {
//         id: 0, // Assuming this is auto-generated by the database
//         name: role_name.to_string(),
//     };

//     // Insert the new role into the database
//     let result = create_role(conn, &role).await?;
//     Ok(result)
// }

// // Function to retrieve a role by its name
// pub async fn get_role_by_name(conn: &Pool, role_name: &str) -> Result<Option<Role>> {
//     find_role_by_name(conn, role_name).await
// }

// // Other user management functions can be added here as needed...
// #[cfg(test)]
// mod tests {
//     use super::*;
//     use diesel::connection::Connection;
//     use diesel::r2d2::{ConnectionManager, PooledConnection};
//     use mockall::mock;
//     use serial_test::serial;

//     mock! {
//         ConnectionManager<PgConnection> {}
//         impl Connection for PooledConnection<ConnectionManager<PgConnection>> {
//             fn execute(&mut self, query: &str) -> QueryResult<usize>;
//             fn query_by_index<T, U>(&mut self, source: T) -> QueryResult<Vec<U>>
//             where
//                 T: LoadQuery<Self, U>;
//         }
//     }

//     #[tokio::test]
//     #[serial]
//     async fn test_register_user() {
//         let pool = establish_connection_pool().unwrap();
//         let username = "testuser";
//         let email = "testuser@example.com";
//         let password = "testpassword";
//         let role_name = Some("user");

//         let result = register_user(&pool, username, email, password, role_name).await;
//         assert!(result.is_ok());
//     }

//     #[tokio::test]
//     #[serial]
//     async fn test_find_user_by_username() {
//         let pool = establish_connection_pool().unwrap();
//         let username = "testuser";

//         let user = find_user_by_username(&pool, username).await.unwrap();
//         assert_eq!(user.unwrap().username, username);
//     }

//     #[tokio::test]
//     #[serial]
//     async fn test_create_role() {
//         let pool = establish_connection_pool().unwrap();
//         let role = Role {
//             id: 0,
//             name: "admin".to_string(),
//         };

//         let result = create_role(&pool, &role).await;
//         assert!(result.is_ok());
//     }

//     #[tokio::test]
//     #[serial]
//     async fn test_find_role_by_name() {
//         let pool = establish_connection_pool().unwrap();
//         let role_name = "admin";

//         let role = find_role_by_name(&pool, role_name).await.unwrap();
//         assert_eq!(role.unwrap().name, role_name);
//     }
// }
